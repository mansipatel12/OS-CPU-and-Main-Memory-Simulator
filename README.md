# OS-CPU-and-Main-Memory-Simulator
Project Purpose
This project was intended to simulate the relationship between the CPU and the main memory for instruction execution. The relationship between the CPU and the main memory was represented through processes and interprocess communication. The CPU and the main memory were implemented as separate processes that communicated with each other. The project enforced many concepts that are crucial to the functionality of an operating system. These concepts include interaction between the CPU and the main memory, the CPU instruction cycle, the use of registers and the stack, procedure calls, system calls, interrupt processing, memory protection, I/O processing, and virtualization. The project allowed me to receive a hands-on understanding of the relationships and functionalities of the CPU and the main memory within a computer system. 

Project Implementation 
I utilized Java for the project, which included the Runtime exec function and streams to perform interprocess communication. I created two classes for my implementation: a CPU class and a MainMemory class. The CPU class utilized the Runtime exec function to create a child process, which executed the MainMemory class. The CPU class was responsible for fetching and executing the instructions passed from the MainMemory class. The CPU class consisted of integer variables to emulate the standard registers, which include the PC, SP, IR, AC, and temporary registers X and Y. The PC, IR, AC, and registers X and Y were initialized to zero at the beginning of the program. Based on the mode of the computer system, the SP was initialized accordingly. If the computer system was in user mode, the SP was initialized to 1000 at the beginning of the program; if the computer system was in kernel mode, the SP was then initialized to 2000.  I created additional variables to assist in holding arguments from the command line, to use when changing modes, or to use when processing a new instruction. I created an integer instruction_count variable to track the instruction count for interrupts. I created InputStream and OutputStream objects for the process running Main Memory; these objects were utilized in communication between the MainMemory class and the CPU class. I used a Scanner object to read input given from the main memory. Before beginning my instruction cycle, I sent the initial PC (which was zero) to the MainMemory class and read the output into the IR variable. This set up the initial read from the MainMemory class, which then started the instruction cycle in the CPU class. Within the instruction cycle, fetch and execute steps occurred for each instruction. At the beginning of the instruction cycle, the previous instruction from the main memory was read into a temporary variable, after which the updated PC was sent to the MainMemory class and the new instruction was read into the IR variable. After fetching the instruction from the MainMemory class, I utilized a switch statement for each instruction value to match with the contents of the IR variable. Based on the value of the IR, the corresponding block in the switch statement would execute as the instruction. For certain instructions, multiple read instructions had to occur to retrieve the necessary information to complete the requested instruction. In each block of the switch statement (excluding instruction 50 for ending the program and the default case), the PC was either incremented or updated to a given value. After the switch statement, the instruction count was incremented as the CPU completed the execution of an instruction. The CPU class then checked if the instruction count was equal to the timer interrupt value, and if it was, an interrupt had to occur. To prepare for the interrupt, the computer system switched from user mode to kernel mode, the PC and user SP were pushed onto the system stack, the PC was initialized to 1000, and the instruction count was reset. A similar procedure was followed when a system call occurred. In the MainMemory class, the input file name from the CPU class was first processed. The input file consisted of a user program, and each line of the file was parsed and stored into a 2000-size integer array in the MainMemory class. Each instruction line was stored sequentially unless the line consisted of a period at the front. The period at the front indicated a change in loading address, after which the input file would be read in at the index stated in that line. The integer array emulated the memory storage. Indexes 0 to 999 of the array were allocated for the user program and user stack, and indexes 1000 – 1999 were allocated for the system stack. I created a Scanner object to read commands sent from the CPU class. The MainMemory class was intended to support two operations: read from a given address in memory or write data to an address in memory. Once reading in the input file into the integer array, I created an infinite loop that continuously processed commands from the CPU class. The CPU class would send any of the following commands: “read”, “write”, “exit”, or “done”. For a “read” command, the MainMemory class read in an address from the CPU class, and then output the value at that address in the integer array. The output would be sent to the CPU class. For a “write” command, the MainMemory class read in the address and the data that would be written to that address from the CPU class. The MainMemory class then stored the data at that address in the integer array. I created an inner while loop within the infinite loop that processed these commands until the CPU class sent the “done” command. This is because a single instruction may require several reads and/or writes to fully perform the request. The “done” command indicated that the CPU class completed the current instruction, and the MainMemory class would then output the processed instruction. This output would allow the instruction cycle in the CPU class to progress further. Once the CPU class received the instruction 50 from the MainMemory class, the exit instruction would execute. The CPU class would send the “exit” command to the MainMemory class, which would cause the loops in the MainMemory class to break and the class would return. The CPU class would wait for the MainMemory process to complete and then return as well. 

My Experience
The project posed a challenge for me as I was new to processes and interprocess communication in Java. I was familiar with processes and pipes in C++ and C using Unix, so I was able to use a little bit of my previous knowledge when implementing the project. I first began the project by thoroughly reading the instructions, understanding the required structure for the implementation, and understanding the given examples in Java. I feel that the project allowed me to solidify my understanding of the functionalities of the CPU and main memory. It also gave me the experience of creating processes and managing interprocess communication in Java. 
